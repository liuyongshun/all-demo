<!DOCTYPE html>
<html>

	<head>
		<meta charset="UTF-8">
    <title></title>
    <style>
      .item-lazy-img-box {
        margin: 20px auto;
        width: 700px;
        border: 1px solid #ddd;
        /* 用来站位，如果没有一个初始站位，会加载全部，因为高度没有撑开，素有 */
        padding-bottom: 45.4%;
      }
      .item-lazy-img-box img {
        display: block;
        width: 100%;
      }
    </style>
	</head>

	<body>
    <!-- 懒加载 -->
    <!-- <div class="item-lazy-img-box"><img src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=106869756,2517427910&fm=26&gp=0.jpg" src-placeholder="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1212634408,3098005759&fm=26&gp=0.jpg" alt=""></div>
    <div class="item-lazy-img-box"><img src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=106869756,2517427910&fm=26&gp=0.jpg" src-placeholder="https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=137056439,1749348804&fm=26&gp=0.jpg" alt=""></div>
    <div class="item-lazy-img-box"><img src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=106869756,2517427910&fm=26&gp=0.jpg" src-placeholder="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1383631049,497967470&fm=26&gp=0.jpg" alt=""></div>
    <div class="item-lazy-img-box"><img src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=106869756,2517427910&fm=26&gp=0.jpg" src-placeholder="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3092093306,2016584804&fm=26&gp=0.jpg" alt=""></div>
    <div class="item-lazy-img-box"><img src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=106869756,2517427910&fm=26&gp=0.jpg" src-placeholder="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1565497032,1186325569&fm=26&gp=0.jpg" alt=""></div>
    <div class="item-lazy-img-box"><img src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=106869756,2517427910&fm=26&gp=0.jpg" src-placeholder="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=3821866890,593617715&fm=26&gp=0.jpg" alt=""></div>
    <div class="item-lazy-img-box"><img src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=106869756,2517427910&fm=26&gp=0.jpg" src-placeholder="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=2852448413,2190881300&fm=15&gp=0.jpg" alt=""></div>
    <div class="item-lazy-img-box"><img src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=106869756,2517427910&fm=26&gp=0.jpg" src-placeholder="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=2555113363,943959302&fm=26&gp=0.jpg" alt=""></div>

    <script>
      let count = 0;
      (function lazyLoad(){
        const imageToLazy = document.querySelectorAll('img[src-placeholder]');
        const loadImage = function (image) {
          image.setAttribute('src', image.getAttribute('src-placeholder'));
          image.addEventListener('load', function() {
            image.removeAttribute("src-placeholder");
          })
        }

        const intersectionObserver = new IntersectionObserver(function(items, observer) {
          count++
          console.log(items)
          items.forEach(function(item) {
            if(item.isIntersecting) {
              loadImage(item.target);
              observer.unobserve(item.target);
            }
          });
        });

        imageToLazy.forEach(function(image){
          intersectionObserver.observe(image);
        })
    })()
    </script> -->
    <!-- =====================api===================== -->
    <div style="width: 100%;height: 1200px;"></div>
    <div id="watch">
      滚动到该视口时才会触发回调
      离开时也会触发回调
    </div>
    <div style="width: 100%;height: 1200px;"></div>
    <script>
      // 回调初次加载会触发，每当监听 dom 进入视口和离开视口时就会触发，
      const io = new IntersectionObserver((e) => {
        console.log(e)
      })
      io.observe(document.getElementById('watch'))
    </script>
    <script>
      // 使用：
      // 是以new的形式声明一个对象，接收两个参数callback和options
      // const io = new IntersectionObserver(callback, options)
      // io.observe(DOM)
      // 开始监测，多个dom多次调用
      // io.observe(document.getElementById('example'));
      // // 停止观察
      // io.unobserve(element);
      // // 关闭观察器
      // io.disconnect();
      // callback ：entry 和 observer

      // entry 是一个数组

      // 每一项的字段
      // time：可见性发生变化的时间，是一个高精度时间戳，单位为毫秒
      // target：被观察的目标元素，是一个 DOM 节点对象
      // rootBounds：根元素的矩形区域的信息，getBoundingClientRect()方法的返回值，如果没有根元素（即直接相对于视口滚动），则返回null
      // boundingClientRect：目标元素的矩形区域的信息
      // intersectionRect：目标元素与视口（或根元素）的交叉区域的信息
      // intersectionRatio：目标元素的可见比例，即intersectionRect占boundingClientRect的比例，完全可见时为1，完全不可见时小于等于0，监听dom进入视口的面积百分比

      // observer:
      // 被调用的IntersectionObserver实例,支持方法
      // IntersectionObserver.disconnect()
      // 使IntersectionObserver对象停止监听工作。
      // IntersectionObserver.observe()
      // 使IntersectionObserver开始监听一个目标元素。
      // IntersectionObserver.takeRecords()
      // 返回所有观察目标的IntersectionObserverEntry对象数组。
      // IntersectionObserver.unobserve()
      // 使IntersectionObserver停止监听特定目标元素。

      // options 参数“：
      // 一个可以用来配置observer实例的对象。如果options未指定，observer实例默认使用文档视口作为root，并且没有margin，阈值为0%（意味着即使一像素的改变都会触发回调函数）。你可以指定以下配置：
      // root 自定义指定视口元素（父级容器） 监听元素的祖先元素Element对象，其边界盒将被视作视口。目标在根的可见区域的的任何不可见部分都会被视为不可见。

      // rootMargin 一个在计算交叉值时添加至根的边界盒(bounding_box)中的一组偏移量，类型为字符串(string) ，可以有效的缩小或扩大根的判定范围从而满足计算需要。语法大致和CSS 中的margin 属性等同; 可以参考 The root element and root margin in Intersection Observer API来深入了解margin的工作原理及其语法。默认值是"0px 0px 0px 0px"。
    // threshold 规定了一个监听目标与边界盒交叉区域的比例值，可以是一个具体的数值或是一组0.0到1.0之间的数组。若指定值为0.0，则意味着监听元素即使与根有1像素交叉，此元素也会被视为可见. 若指定值为1.0，则意味着整个元素都是可见的(此段英文原文直译，正确性有待验证) 。可以参考Thresholds in Intersection Observer API 来深入了解阈值是如何使用的。阈值的默认值为0.0。
    </script>
	</body>
</html>
